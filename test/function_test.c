#include "HiAE.h"
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#define REPEAT 2500

#define MIN(a, b) a > b ? b : a
#define MAX(a, b) a > b ? a : b

void
print_data(const uint8_t *data, size_t len)
{
    for (size_t i = 0; i < len; ++i) {
        printf("0x%02x, ", data[i]);
    }
    printf("\n");
}

int
functional_test_work(size_t plain_len, size_t ad_len)
{
    uint8_t key[HIAE_KEYBYTES];
    uint8_t nonce[HIAE_NONCEBYTES];

    uint8_t *ad     = (uint8_t *) malloc(ad_len);
    uint8_t *msg    = (uint8_t *) malloc(plain_len);
    uint8_t *ct     = (uint8_t *) malloc(plain_len);
    uint8_t *decode = (uint8_t *) malloc(plain_len);

    for (int i = 0; i < HIAE_KEYBYTES; i++)
        key[i] = rand() % 256;
    for (int i = 0; i < HIAE_NONCEBYTES; i++)
        nonce[i] = rand() % 256;
    for (size_t i = 0; i < plain_len; i++)
        msg[i] = rand() % 256;
    for (size_t i = 0; i < ad_len; i++)
        ad[i] = rand() % 256;

    uint8_t tag1[HIAE_MACBYTES], tag2[HIAE_MACBYTES];

    HiAE_state_t state;

    int rnd_0, rnd_1, rnd_2, rnd_3;
    rnd_0 = rand() % ad_len;
    rnd_1 = rand() % plain_len;
    rnd_2 = rand() % plain_len;
    rnd_3 = rand() % ad_len;
    rnd_0 -= rnd_0 % 16;
    rnd_1 -= rnd_1 % 16;
    rnd_2 -= rnd_2 % 16;
    rnd_3 -= rnd_3 % 16;

    HiAE_init(&state, key, nonce);
    HiAE_absorb(&state, ad, rnd_0);
    HiAE_absorb(&state, ad + rnd_0, (ad_len - rnd_0));
    HiAE_enc(&state, ct, msg, rnd_1);
    HiAE_enc(&state, ct + rnd_1, msg + rnd_1, (plain_len - rnd_1));
    HiAE_finalize(&state, ad_len, plain_len, tag1);

    HiAE_init(&state, key, nonce);
    HiAE_absorb(&state, ad, rnd_3);
    HiAE_absorb(&state, ad + rnd_3, (ad_len - rnd_3));
    HiAE_dec(&state, decode, ct, rnd_2);
    HiAE_dec(&state, decode + rnd_2, ct + rnd_2, (plain_len - rnd_2));
    HiAE_finalize(&state, ad_len, plain_len, tag2);

    int same_msg = memcmp(msg, decode, plain_len);
    int same_tag = memcmp(tag1, tag2, HIAE_MACBYTES);
    free(ad);
    free(msg);
    free(ct);
    free(decode);

    if (!(same_msg | same_tag)) {
        return 1;
    }
    return 0;
}

void
functional_test(void)
{
    int result = 0;
    srand(time(NULL));
    int    size_group = 6;
    double avg_ad = 0, avg_len = 0;
    int    max_len = 0, min_len = 1 << 30, max_ad = 0, min_ad = 1 << 30;
    int    size_L[7] = { 1, 256, 1024, 8192, 16384, 32768, 65536 };
    for (int i = 0; i < size_group; i++) {
        int T = REPEAT;
        while (T--) {
            int len    = rand() % (size_L[i + 1] - size_L[i] + 1) + size_L[i];
            int ad_len = rand() % (size_L[i + 1] - size_L[i] + 1) + size_L[i];
            result += functional_test_work(len, ad_len);
            avg_ad += ad_len;
            avg_len += len;
            max_len = MAX(max_len, len);
            min_len = MIN(min_len, len);
            max_ad  = MAX(max_ad, ad_len);
            min_ad  = MIN(min_ad, ad_len);
        }
    }
    if (result == REPEAT * size_group) {
        printf("functional test pass.  \t");
    } else {
        printf("functional test failed!  \t");
    }
    printf("passed: %d of total %d test cases.\n", result, REPEAT * size_group);
    printf("average AD len: %.2f Bytes \t average message len: %.2f Bytes\n",
           avg_ad / REPEAT / size_group, avg_len / REPEAT / size_group);
}

int
stream_API_test_case_1(void)
{
    uint8_t key[HIAE_KEYBYTES];
    uint8_t nonce[HIAE_NONCEBYTES];

    memset(key, 0x7, HIAE_KEYBYTES);
    memset(nonce, 0x3, HIAE_NONCEBYTES);

    size_t plain_len = 64;
    size_t ad_len    = 48;

    int passed = 0;

    uint8_t *ad     = (uint8_t *) malloc(ad_len);
    uint8_t *msg    = (uint8_t *) malloc(plain_len);
    uint8_t *ct     = (uint8_t *) malloc(plain_len);
    uint8_t *decode = (uint8_t *) malloc(plain_len);

    memset(ad, 0x1, ad_len);
    memset(msg, 0x1, plain_len);

    uint8_t tag1[HIAE_MACBYTES];

    HiAE_state_t state;

    uint8_t correct_state_init[256] = {
        0x48, 0x1e, 0x3f, 0x9e, 0x47, 0xa3, 0x8a, 0x4e, 0x1f, 0xe4, 0x7f, 0x53, 0xb6, 0xd1, 0xed,
        0x58, 0x08, 0x7b, 0xf5, 0x91, 0xda, 0x61, 0xa9, 0x9c, 0x78, 0x1d, 0x6c, 0x03, 0xb9, 0xa8,
        0x2f, 0x59, 0xc0, 0xe2, 0x90, 0xd4, 0x47, 0x67, 0x4e, 0x03, 0x70, 0xac, 0x89, 0x46, 0x04,
        0x48, 0x43, 0x06, 0xe7, 0x91, 0x3e, 0x75, 0xcd, 0x52, 0x10, 0x9a, 0x49, 0x07, 0x18, 0x55,
        0xf8, 0x18, 0x11, 0x5d, 0x59, 0xd2, 0x17, 0x0f, 0x27, 0x28, 0x3e, 0xc2, 0xd9, 0x29, 0xf2,
        0xf7, 0xa2, 0xe3, 0x91, 0x3b, 0x15, 0x61, 0x84, 0x6a, 0x1f, 0x2f, 0x4c, 0xfa, 0x07, 0x61,
        0xdf, 0x12, 0xd0, 0xbb, 0xde, 0x65, 0xaa, 0x98, 0x53, 0xeb, 0x25, 0x65, 0x2b, 0x73, 0x99,
        0x24, 0x69, 0x5c, 0xde, 0x48, 0xcb, 0xe2, 0xc9, 0x16, 0xb6, 0xec, 0xa9, 0xba, 0x9c, 0x5a,
        0xa0, 0xcb, 0x0b, 0x11, 0x1e, 0x90, 0x15, 0x56, 0x3f, 0xad, 0xcc, 0x78, 0x51, 0x52, 0xcd,
        0x34, 0x1b, 0x0f, 0x7c, 0x59, 0x3b, 0x69, 0x12, 0xad, 0x41, 0xc2, 0x89, 0x7f, 0xe1, 0x0c,
        0x94, 0x26, 0x4b, 0xf8, 0xbe, 0xb4, 0xd2, 0x1c, 0x22, 0xb3, 0x77, 0x6a, 0xd7, 0xe2, 0xd6,
        0xc3, 0x8d, 0x47, 0x3e, 0xcd, 0xa5, 0x97, 0xf1, 0xe5, 0x7d, 0xc4, 0xaa, 0xbf, 0x2a, 0x1f,
        0xbe, 0x7a, 0xa0, 0x36, 0xed, 0xd0, 0xcf, 0xc8, 0x03, 0xec, 0x01, 0x74, 0x23, 0x54, 0x1c,
        0xda, 0x21, 0xda, 0x9e, 0x46, 0x75, 0x1f, 0xd4, 0x31, 0xc7, 0x79, 0x77, 0x9d, 0x96, 0x61,
        0x7f, 0x52, 0xc2, 0xa6, 0x7f, 0xcd, 0x1b, 0x30, 0x72, 0x8f, 0xe3, 0xca, 0x05, 0x41, 0xd4,
        0x78, 0xad, 0x47, 0x35, 0x55, 0xe3, 0xf3, 0x77, 0xa1, 0x7b, 0x04, 0x53, 0xb8, 0x81, 0x6b,
        0x03, 0xfe, 0xf0, 0x19, 0xd4, 0xaf, 0xf6, 0x6f, 0x02, 0x6d, 0x30, 0x33, 0x75, 0x7e, 0xa6,
        0x6c
    };
    uint8_t correct_state_ad[256] = {
        0xe6, 0x90, 0x3f, 0x74, 0xcc, 0x53, 0x11, 0x9b, 0x48, 0x06, 0x19, 0x54, 0xf9, 0x19, 0x10,
        0x5c, 0x58, 0xd3, 0x16, 0x0e, 0x26, 0x29, 0x3f, 0xc3, 0xd8, 0x28, 0xf3, 0xf6, 0xa3, 0xe2,
        0x90, 0x3a, 0x14, 0x60, 0x85, 0x6b, 0x1e, 0x2e, 0x4d, 0xfb, 0x06, 0x60, 0xde, 0x13, 0xd1,
        0xba, 0xdf, 0x64, 0xaa, 0x98, 0x53, 0xeb, 0x25, 0x65, 0x2b, 0x73, 0x99, 0x24, 0x69, 0x5c,
        0xde, 0x48, 0xcb, 0xe2, 0xc9, 0x16, 0xb6, 0xec, 0xa9, 0xba, 0x9c, 0x5a, 0xa0, 0xcb, 0x0b,
        0x11, 0x1e, 0x90, 0x15, 0x56, 0x3f, 0xad, 0xcc, 0x78, 0x51, 0x52, 0xcd, 0x34, 0x1b, 0x0f,
        0x7c, 0x59, 0x3b, 0x69, 0x12, 0xad, 0x41, 0xc2, 0x89, 0x7f, 0xe1, 0x0c, 0x94, 0x26, 0x4b,
        0xf8, 0xbe, 0xb4, 0xd2, 0x1c, 0x22, 0xb3, 0x77, 0x6a, 0xd7, 0xe2, 0xd6, 0xc3, 0x8d, 0x47,
        0x3e, 0xcd, 0xa5, 0x97, 0xf1, 0xe5, 0x7d, 0xc4, 0xaa, 0xbf, 0x2a, 0x1f, 0xbe, 0x7a, 0xa0,
        0x36, 0xed, 0xd0, 0xcf, 0xc8, 0x03, 0xec, 0x01, 0x74, 0x23, 0x54, 0x1c, 0xda, 0x21, 0xda,
        0x9e, 0x46, 0x75, 0x1f, 0xd4, 0x31, 0xc7, 0x79, 0x77, 0x9d, 0x97, 0x60, 0x7e, 0x53, 0xc3,
        0xa7, 0x7e, 0xcc, 0x1a, 0x31, 0x73, 0x8e, 0xe2, 0xcb, 0x04, 0x40, 0xd5, 0x79, 0xac, 0x46,
        0x34, 0x54, 0xe2, 0xf2, 0x76, 0xa0, 0x7a, 0x05, 0x52, 0xb9, 0x80, 0x6a, 0x02, 0xff, 0xf1,
        0x18, 0xd5, 0xae, 0xf7, 0x6e, 0x03, 0x6c, 0x31, 0x32, 0x74, 0x7f, 0xa7, 0x6d, 0xe9, 0x22,
        0xf9, 0x68, 0x73, 0xff, 0xe1, 0xb3, 0xa6, 0x4d, 0xa6, 0x0b, 0xe6, 0x1e, 0x57, 0xbe, 0xbc,
        0x3f, 0x12, 0xea, 0x0d, 0x0c, 0xc2, 0x63, 0x12, 0x60, 0x83, 0xb7, 0xdb, 0x3a, 0x6a, 0x57,
        0x2b, 0x0d, 0x0d, 0x4c, 0xbd, 0x3b, 0x31, 0xaf, 0x9c, 0xdf, 0x8b, 0x81, 0x19, 0xa3, 0x2c,
        0x23
    };
    uint8_t correct_state_enc[256] = {
        0xc8, 0x17, 0xb7, 0xed, 0xa8, 0xbb, 0x9d, 0x5b, 0xa1, 0xca, 0x0a, 0x10, 0x1f, 0x91, 0x14,
        0x57, 0x3e, 0xac, 0xcd, 0x79, 0x50, 0x53, 0xcc, 0x35, 0x1a, 0x0e, 0x7d, 0x58, 0x3a, 0x68,
        0x13, 0xac, 0x40, 0xc3, 0x88, 0x7e, 0xe0, 0x0d, 0x95, 0x27, 0x4a, 0xf9, 0xbf, 0xb5, 0xd3,
        0x1d, 0x23, 0xb2, 0x77, 0x6a, 0xd7, 0xe2, 0xd6, 0xc3, 0x8d, 0x47, 0x3e, 0xcd, 0xa5, 0x97,
        0xf1, 0xe5, 0x7d, 0xc4, 0xaa, 0xbf, 0x2a, 0x1f, 0xbe, 0x7a, 0xa0, 0x36, 0xed, 0xd0, 0xcf,
        0xc8, 0x03, 0xec, 0x01, 0x74, 0x23, 0x54, 0x1c, 0xda, 0x21, 0xda, 0x9e, 0x46, 0x75, 0x1f,
        0xd4, 0x31, 0xc7, 0x79, 0x77, 0x9d, 0x97, 0x60, 0x7e, 0x53, 0xc3, 0xa7, 0x7e, 0xcc, 0x1a,
        0x31, 0x73, 0x8e, 0xe2, 0xcb, 0x04, 0x40, 0xd5, 0x79, 0xac, 0x46, 0x34, 0x54, 0xe2, 0xf2,
        0x76, 0xa0, 0x7a, 0x05, 0x52, 0xb9, 0x80, 0x6a, 0x02, 0xff, 0xf1, 0x18, 0xd5, 0xae, 0xf7,
        0x6e, 0x03, 0x6c, 0x31, 0x32, 0x74, 0x7f, 0xa7, 0x6d, 0xe8, 0x23, 0xf8, 0x69, 0x72, 0xfe,
        0xe0, 0xb2, 0xa7, 0x4c, 0xa7, 0x0a, 0xe7, 0x1f, 0x56, 0xbf, 0xbd, 0x3e, 0x13, 0xeb, 0x0c,
        0x0d, 0xc3, 0x62, 0x13, 0x61, 0x82, 0xb6, 0xda, 0x3b, 0x6b, 0x56, 0x2a, 0x0c, 0x0c, 0x4d,
        0xbc, 0x3a, 0x30, 0xae, 0x9d, 0xde, 0x8a, 0x80, 0x18, 0xa2, 0x2d, 0x22, 0x0a, 0x50, 0x9d,
        0x85, 0x74, 0x89, 0x57, 0x79, 0x34, 0xfd, 0x48, 0x83, 0x38, 0x68, 0x03, 0x32, 0xe3, 0x64,
        0x1b, 0xdc, 0x6b, 0x95, 0x01, 0xe1, 0x7e, 0xd9, 0x0a, 0x7a, 0xd5, 0x17, 0xba, 0x8c, 0xf6,
        0x34, 0x79, 0x34, 0xe8, 0x5d, 0x34, 0x86, 0xbe, 0x74, 0x03, 0x1c, 0x4c, 0x07, 0xd1, 0xca,
        0x8b, 0x83, 0x60, 0x3d, 0xa9, 0x02, 0xf6, 0x3b, 0xbf, 0xbe, 0x38, 0x3b, 0xe1, 0xfa, 0x5a,
        0xc9
    };
    uint8_t correct_state_final[256] = {
        0x6f, 0x6d, 0x44, 0x12, 0x08, 0x20, 0x2a, 0xa5, 0x71, 0xa0, 0x02, 0x73, 0x0b, 0x32, 0x3e,
        0x34, 0x47, 0x46, 0x01, 0x40, 0x17, 0xab, 0x56, 0x0f, 0x0d, 0x05, 0xfc, 0xbe, 0xaa, 0x27,
        0xae, 0x3e, 0xcd, 0x99, 0x89, 0xce, 0xbd, 0xd5, 0xd1, 0x54, 0x26, 0x20, 0x25, 0x37, 0xf6,
        0x28, 0x43, 0xc3, 0xdc, 0x5e, 0x90, 0x0d, 0x49, 0x4d, 0x50, 0x09, 0xdb, 0x15, 0xf8, 0x64,
        0xc3, 0xec, 0xf8, 0xce, 0x06, 0x19, 0x01, 0x46, 0x69, 0x34, 0x14, 0xa3, 0xbd, 0x21, 0x39,
        0xae, 0x42, 0x89, 0x78, 0x66, 0x2a, 0x64, 0x1d, 0xa1, 0x51, 0x62, 0x39, 0x9d, 0xe1, 0x9a,
        0x3f, 0xe1, 0xb0, 0x72, 0x8a, 0x4b, 0xdc, 0x22, 0x7e, 0x99, 0xa9, 0x22, 0x94, 0xda, 0xb1,
        0x6c, 0xd7, 0x21, 0x76, 0xf2, 0x42, 0x2c, 0x1d, 0xbc, 0x57, 0xe9, 0x1a, 0xda, 0x45, 0xdd,
        0x77, 0x7f, 0x14, 0x65, 0xb0, 0x74, 0xf1, 0x1d, 0x1d, 0x4e, 0x27, 0xd6, 0x51, 0x72, 0x41,
        0xa2, 0x8e, 0x64, 0x6c, 0xea, 0x9a, 0x97, 0x9d, 0xc6, 0x7a, 0x30, 0xa4, 0x67, 0xbb, 0xdd,
        0x44, 0x74, 0x3b, 0x7a, 0x50, 0xd6, 0xd5, 0xc7, 0xe9, 0x69, 0xe1, 0x4a, 0xb6, 0x49, 0xcc,
        0xc3, 0x0d, 0x98, 0x36, 0xf8, 0xfa, 0x54, 0x98, 0x03, 0x17, 0x77, 0x68, 0x4c, 0x43, 0xd8,
        0x6b, 0x46, 0xb5, 0x49, 0x72, 0x8c, 0x2b, 0xf1, 0xb0, 0xce, 0xad, 0xb0, 0xa3, 0x4c, 0x6c,
        0xd9, 0x78, 0xcf, 0x31, 0x06, 0xb5, 0x18, 0x40, 0x8b, 0x51, 0x8d, 0x7e, 0x13, 0x50, 0x65,
        0x9c, 0x9f, 0xbc, 0xf4, 0x21, 0xc5, 0x0b, 0x7c, 0xa9, 0xb3, 0xa6, 0x61, 0x22, 0xc7, 0xab,
        0xad, 0x39, 0x25, 0x7f, 0xaf, 0xba, 0xa1, 0x68, 0xb5, 0x79, 0x13, 0xd9, 0x41, 0xb1, 0x7c,
        0x18, 0xbd, 0x55, 0xe1, 0xa0, 0xac, 0xd4, 0x69, 0x30, 0x29, 0x87, 0x65, 0x25, 0xbc, 0xcd,
        0x8e
    };
    uint8_t correct_tag[HIAE_MACBYTES] = { 0x7a, 0x4e, 0x83, 0xa4, 0x36, 0xaf, 0xc2, 0xc2,
                                           0x0c, 0xaa, 0x1c, 0x42, 0xcc, 0x20, 0x84, 0x55 };
    uint8_t correct_cipher_text[64] = { 0xa4, 0xf5, 0x29, 0x09, 0x71, 0xa8, 0xdd, 0x86, 0x6a, 0xfe,
                                        0x55, 0xee, 0x84, 0x9b, 0xfe, 0x1a, 0x10, 0xf2, 0xd0, 0x84,
                                        0xf3, 0xdf, 0xee, 0x88, 0x44, 0x81, 0xaf, 0x10, 0x4d, 0x49,
                                        0xd8, 0x05, 0xfc, 0x02, 0xd6, 0xe9, 0xc9, 0xee, 0xab, 0x47,
                                        0xdf, 0x05, 0x93, 0x4f, 0x04, 0x81, 0xd3, 0xcf, 0x70, 0x4a,
                                        0x56, 0x3a, 0xbe, 0x8c, 0x23, 0x90, 0xf9, 0x68, 0x1e, 0xec,
                                        0x7b, 0xf5, 0x72, 0xd4 };

    HiAE_init(&state, key, nonce);
    int same_state_init = memcmp(&state, correct_state_init, 256);

    passed |= same_state_init;
    if (!same_state_init)
        printf("passed API: [HiAE_init] test\n");
    else
        printf("API error: [HiAE_init] !\n");

    HiAE_absorb(&state, ad, ad_len);

    int same_state_ad = memcmp(&state, correct_state_ad, 256);
    passed |= same_state_ad;
    if (!same_state_ad)
        printf("passed API: [HiAE_absorb] test\n");
    else
        printf("API error: [HiAE_absorb] !\n");

    HiAE_enc(&state, ct, msg, plain_len);

    int same_state_enc  = memcmp(&state, correct_state_enc, 256);
    int same_cipher_enc = memcmp(ct, correct_cipher_text, plain_len);

    passed |= same_state_enc | same_cipher_enc;
    if (!(same_state_enc | same_cipher_enc))
        printf("passed API: [HiAE_enc] test\n");
    else
        printf("API error: [HiAE_enc] !\n");

    HiAE_finalize(&state, ad_len, plain_len, tag1);
    int same_state_final = memcmp(&state, correct_state_final, 256);
    int same_tag         = memcmp(tag1, correct_tag, HIAE_MACBYTES);

    passed |= same_state_final | same_tag;
    if (!(same_state_final | same_tag))
        printf("passed API: [HiAE_finalize] test\n");
    else
        printf("API error: [HiAE_finalize] !\n");

    HiAE_init(&state, key, nonce);
    HiAE_absorb(&state, ad, ad_len);
    HiAE_dec(&state, decode, correct_cipher_text, plain_len);
    int same_state_dec  = memcmp(&state, correct_state_enc, 256);
    int same_cipher_dec = memcmp(msg, decode, plain_len);
    passed |= same_state_dec | same_cipher_dec;
    if (!(same_state_dec | same_cipher_dec))
        printf("passed API: [HiAE_dec] test\n");
    else
        printf("API error: [HiAE_dec] !\n");

    free(ad);
    free(msg);
    free(ct);
    free(decode);

    return passed;
}

int
AEAD_API_test_case_1(void)
{
    uint8_t key[HIAE_KEYBYTES];
    uint8_t nonce[HIAE_NONCEBYTES];

    memset(key, 0x5, HIAE_KEYBYTES);
    memset(nonce, 0x4, HIAE_NONCEBYTES);

    size_t plain_len = 384;
    size_t ad_len    = 80;

    int passed = 0;

    uint8_t *ad     = (uint8_t *) malloc(ad_len);
    uint8_t *msg    = (uint8_t *) malloc(plain_len);
    uint8_t *ct     = (uint8_t *) malloc(plain_len);
    uint8_t *decode = (uint8_t *) malloc(plain_len);

    memset(ad, 0x2, ad_len);
    memset(msg, 0x3, plain_len);

    uint8_t tag[HIAE_MACBYTES];

    uint8_t correct_tag_AEAD[HIAE_MACBYTES] = { 0x5a, 0x11, 0x98, 0xef, 0x71, 0xdd, 0xcb, 0xfb,
                                                0xe0, 0x3d, 0xee, 0x1b, 0x98, 0xfc, 0x0b, 0x04 };
    uint8_t correct_cipher_text_AEAD[384]   = {
        0x66, 0x2f, 0x8b, 0xfc, 0x5e, 0x24, 0xd1, 0x3a, 0x14, 0x80, 0x45, 0xb2, 0xff, 0x5e, 0x58,
        0xaf, 0x5d, 0xb2, 0xb8, 0xc2, 0xf9, 0xf1, 0x01, 0x55, 0x30, 0xaf, 0xb8, 0xf6, 0xea, 0x45,
        0x06, 0x14, 0x47, 0x78, 0x04, 0x10, 0xc5, 0x66, 0x96, 0x22, 0x5d, 0x1b, 0x11, 0xa9, 0xef,
        0x94, 0x05, 0xfb, 0x75, 0xc4, 0xb3, 0xb4, 0xc8, 0x49, 0xc6, 0xee, 0x65, 0x8c, 0xde, 0xa9,
        0x7e, 0x48, 0x02, 0x96, 0x0c, 0x28, 0x80, 0xd8, 0x52, 0x12, 0x69, 0xc4, 0xa8, 0xbf, 0x2f,
        0x7c, 0x2c, 0x5e, 0x59, 0xaf, 0xd8, 0xa8, 0xc8, 0x3d, 0x66, 0x83, 0x83, 0x8a, 0x87, 0x03,
        0xf7, 0x78, 0x0b, 0x97, 0x87, 0xce, 0x67, 0xbf, 0x16, 0xdf, 0x8d, 0xf3, 0xb9, 0x28, 0xb3,
        0xb4, 0xe3, 0xd6, 0xfb, 0x49, 0xf6, 0x60, 0xd4, 0x38, 0x0e, 0xf2, 0x6a, 0x25, 0x46, 0xa5,
        0x71, 0xf3, 0xd3, 0x0a, 0x7e, 0xa5, 0x03, 0xea, 0xfa, 0x34, 0xcf, 0x7b, 0x3b, 0x6e, 0x96,
        0xa7, 0xd5, 0x61, 0xc5, 0xeb, 0x91, 0x5f, 0x82, 0xda, 0xf0, 0x58, 0x1e, 0xc8, 0xfd, 0xc7,
        0xd5, 0x4d, 0x6c, 0xeb, 0xe9, 0x66, 0x74, 0x5d, 0xd0, 0x0f, 0x76, 0x7d, 0x87, 0x15, 0x19,
        0x88, 0xd9, 0x83, 0x6e, 0xb1, 0x34, 0xb5, 0xee, 0xae, 0x53, 0x30, 0xa1, 0x81, 0x88, 0x0e,
        0xc7, 0x2b, 0x3b, 0x9c, 0xe2, 0x21, 0xac, 0xed, 0xbc, 0x92, 0x73, 0xbf, 0x88, 0xfd, 0x4c,
        0x5b, 0x26, 0x1c, 0xa4, 0x4c, 0x97, 0x8c, 0xd3, 0x47, 0x24, 0x46, 0x19, 0xe6, 0x3c, 0x6c,
        0x13, 0x49, 0x6d, 0x72, 0xa3, 0x38, 0x76, 0x13, 0x20, 0x65, 0xb7, 0x94, 0xed, 0x9d, 0xf0,
        0x1c, 0xa2, 0x35, 0x26, 0x5a, 0xf0, 0xf8, 0x11, 0x7a, 0x04, 0x4a, 0x43, 0x59, 0xa9, 0x65,
        0x76, 0x99, 0x5c, 0x8c, 0xee, 0xeb, 0x24, 0x70, 0xd8, 0x6c, 0xb1, 0xd6, 0x2b, 0xc2, 0x16,
        0x31, 0xaa, 0xd6, 0x5e, 0x89, 0x80, 0x28, 0x22, 0xb5, 0x64, 0x34, 0x58, 0xbe, 0xee, 0x91,
        0xf6, 0xa0, 0x30, 0x98, 0x3b, 0xf5, 0x75, 0xd2, 0x36, 0xe5, 0x3c, 0x0c, 0x38, 0x1d, 0x38,
        0x4e, 0xbe, 0x77, 0x4e, 0x52, 0x0b, 0xbc, 0xdb, 0xd5, 0x11, 0xcf, 0x60, 0xf6, 0xf2, 0x6d,
        0xd0, 0x8d, 0xdc, 0x80, 0x23, 0xc5, 0x0a, 0xc4, 0x66, 0xe1, 0xd4, 0x5e, 0x6a, 0x22, 0x1f,
        0x4f, 0x01, 0x08, 0x02, 0x05, 0xb6, 0x36, 0x5b, 0x5b, 0xda, 0x85, 0x64, 0x76, 0xf7, 0x54,
        0x49, 0x42, 0xf8, 0xee, 0x82, 0xb3, 0x33, 0xf6, 0xb8, 0x72, 0x94, 0x11, 0x59, 0x9b, 0x5d,
        0x6f, 0xeb, 0x71, 0x51, 0x03, 0x6a, 0x5e, 0x36, 0x5f, 0xd3, 0xde, 0xaa, 0xf2, 0x51, 0xcb,
        0x25, 0x77, 0x83, 0xf9, 0xc7, 0x62, 0xa2, 0x94, 0xb5, 0x50, 0x85, 0x1a, 0x02, 0x50, 0x25,
        0x86, 0x0c, 0xa9, 0xfc, 0x94, 0x4b, 0x3c, 0x67, 0x66
    };
    HiAE_encrypt(key, nonce, msg, ct, plain_len, ad, ad_len, tag);
    int AEAD_enc_pass = memcmp(ct, correct_cipher_text_AEAD, plain_len) |
                        memcmp(tag, correct_tag_AEAD, HIAE_MACBYTES);
    passed |= AEAD_enc_pass;
    if (!AEAD_enc_pass)
        printf("passed API: [HiAE_encrypt] test\n");
    else
        printf("API error: [HiAE_encrypt] !\n");

    HiAE_decrypt(key, nonce, decode, correct_cipher_text_AEAD, plain_len, ad, ad_len, tag);
    int AEAD_dec_pass =
        memcmp(decode, msg, plain_len) | memcmp(tag, correct_tag_AEAD, HIAE_MACBYTES);

    passed |= AEAD_dec_pass;
    if (!AEAD_dec_pass)
        printf("passed API: [HiAE_decrypt] test\n");
    else
        printf("API error: [HiAE_decrypt] !\n");

    free(ad);
    free(msg);
    free(ct);
    free(decode);

    return passed;
}

int
Verification_API_test_case_1(void)
{
    uint8_t key[HIAE_KEYBYTES];
    uint8_t nonce[HIAE_NONCEBYTES];

    memset(key, 0x3, HIAE_KEYBYTES);
    memset(nonce, 0x6, HIAE_NONCEBYTES);

    size_t plain_len = 320;

    int passed = 0;

    uint8_t *msg    = (uint8_t *) malloc(plain_len);
    uint8_t *ct     = (uint8_t *) malloc(plain_len);
    uint8_t *decode = (uint8_t *) malloc(plain_len);

    memset(msg, 0x5, plain_len);

    uint8_t tag[HIAE_MACBYTES];
    uint8_t correct_tag[HIAE_MACBYTES] = { 0x26, 0xc6, 0x35, 0x6f, 0x64, 0x66, 0x53, 0x75,
                                           0xc2, 0x53, 0x39, 0x8a, 0x8b, 0xde, 0xe8, 0xc2 };
    HiAE_mac(key, nonce, msg, plain_len, tag);
    int tag_pass = memcmp(tag, correct_tag, HIAE_MACBYTES);
    passed |= tag_pass;
    if (!tag_pass)
        printf("passed API: [HiAE_mac] test\n");
    else
        printf("API error: [HiAE_mac] !\n");

    free(msg);
    free(ct);
    free(decode);

    return passed;
}

int
Verification_API_test_case_2(void)
{
    uint8_t key[HIAE_KEYBYTES];
    uint8_t nonce[HIAE_NONCEBYTES];

    memset(key, 0x9, HIAE_KEYBYTES);
    memset(nonce, 0x11, HIAE_NONCEBYTES);

    size_t plain_len = 12432;

    int passed = 0;

    uint8_t *msg = (uint8_t *) malloc(plain_len);

    memset(msg, 0x3, plain_len);

    uint8_t tag[HIAE_MACBYTES];

    uint8_t correct_tag[HIAE_MACBYTES] = { 0x19, 0x58, 0x84, 0x80, 0x6e, 0x07, 0x15, 0xc7,
                                           0xc5, 0xbb, 0xaa, 0xb3, 0x85, 0x59, 0x97, 0x36 };
    HiAE_mac(key, nonce, msg, plain_len, tag);
    int tag_pass = memcmp(tag, correct_tag, HIAE_MACBYTES);

    passed |= tag_pass;
    if (!tag_pass)
        printf("passed API: [HiAE_mac] test\n");
    else
        printf("API error: [HiAE_mac] !\n");

    free(msg);

    return passed;
}

int
partial_noupdate_test_case_1(void)
{
    uint8_t key[HIAE_KEYBYTES];
    uint8_t nonce[HIAE_NONCEBYTES];

    memset(key, 0x7, HIAE_KEYBYTES);
    memset(nonce, 0x3, HIAE_NONCEBYTES);

    // Test different partial sizes from 1 to 15 bytes
    int passed = 0;

    for (size_t partial_size = 1; partial_size <= 15; partial_size++) {
        uint8_t plaintext[15];
        uint8_t ciphertext1[15]; // From regular enc
        uint8_t ciphertext2[15]; // From partial_noupdate
        uint8_t decrypted1[15]; // From regular dec
        uint8_t decrypted2[15]; // From partial_noupdate

        // Initialize test data
        for (size_t i = 0; i < partial_size; i++) {
            plaintext[i] = (uint8_t) (0x42 + i);
        }

        HiAE_state_t state1, state2, state3, state4;

        // Initialize identical states
        HiAE_init(&state1, key, nonce);
        HiAE_init(&state2, key, nonce);
        HiAE_init(&state3, key, nonce);
        HiAE_init(&state4, key, nonce);

        // Test 1: Compare regular enc vs enc_partial_noupdate
        HiAE_enc(&state1, ciphertext1, plaintext, partial_size);
        HiAE_enc_partial_noupdate(&state2, ciphertext2, plaintext, partial_size);

        // The ciphertext should be the same
        int same_ciphertext = memcmp(ciphertext1, ciphertext2, partial_size);

        // But the states should be different (noupdate shouldn't modify state)
        int different_states = memcmp(&state1, &state2, sizeof(HiAE_state_t));

        if (same_ciphertext != 0 || different_states == 0) {
            passed = 1;
            printf("FAILED: enc_partial_noupdate test for size %zu\n", partial_size);
            break;
        }

        // Test 2: Compare regular dec vs dec_partial_noupdate
        HiAE_dec(&state3, decrypted1, ciphertext1, partial_size);
        HiAE_dec_partial_noupdate(&state4, decrypted2, ciphertext1, partial_size);

        // The decrypted text should be the same
        int same_decrypted = memcmp(decrypted1, decrypted2, partial_size);

        // But the states should be different (noupdate shouldn't modify state)
        different_states = memcmp(&state3, &state4, sizeof(HiAE_state_t));

        if (same_decrypted != 0 || different_states == 0) {
            passed = 1;
            printf("FAILED: dec_partial_noupdate test for size %zu\n", partial_size);
            break;
        }

        // Test 3: Verify roundtrip consistency
        int roundtrip_success = memcmp(plaintext, decrypted1, partial_size) |
                                memcmp(plaintext, decrypted2, partial_size);

        if (roundtrip_success != 0) {
            passed = 1;
            printf("FAILED: roundtrip test for size %zu\n", partial_size);
            break;
        }
    }

    if (!passed) {
        printf("passed API: [HiAE_enc_partial_noupdate] test\n");
        printf("passed API: [HiAE_dec_partial_noupdate] test\n");
    }

    return passed;
}

int
partial_noupdate_test_case_2(void)
{
    // Test edge cases: zero size and state preservation
    uint8_t key[HIAE_KEYBYTES];
    uint8_t nonce[HIAE_NONCEBYTES];

    memset(key, 0x5, HIAE_KEYBYTES);
    memset(nonce, 0x9, HIAE_NONCEBYTES);

    int passed = 0;

    HiAE_state_t state1, state2;
    uint8_t      dummy_buffer[16];

    // Initialize identical states
    HiAE_init(&state1, key, nonce);
    HiAE_init(&state2, key, nonce);

    // Test with size 0 - should not modify state
    HiAE_enc_partial_noupdate(&state1, dummy_buffer, dummy_buffer, 0);
    HiAE_dec_partial_noupdate(&state2, dummy_buffer, dummy_buffer, 0);

    // States should remain identical
    int states_unchanged = memcmp(&state1, &state2, sizeof(HiAE_state_t));

    if (states_unchanged != 0) {
        passed = 1;
        printf("FAILED: partial_noupdate zero size test\n");
    }

    if (!passed) {
        printf("passed API: [partial_noupdate edge cases] test\n");
    }

    return passed;
}

int
partial_noupdate_functional_test(void)
{
    // Test that partial_noupdate functions work correctly with the stream API
    uint8_t key[HIAE_KEYBYTES];
    uint8_t nonce[HIAE_NONCEBYTES];

    memset(key, 0x1, HIAE_KEYBYTES);
    memset(nonce, 0x2, HIAE_NONCEBYTES);

    size_t ad_len  = 32;
    size_t msg_len = 50; // Not aligned to 16 bytes

    uint8_t *ad       = (uint8_t *) malloc(ad_len);
    uint8_t *msg      = (uint8_t *) malloc(msg_len);
    uint8_t *ct1      = (uint8_t *) malloc(msg_len);
    uint8_t *ct2      = (uint8_t *) malloc(msg_len);
    uint8_t *decoded1 = (uint8_t *) malloc(msg_len);
    uint8_t *decoded2 = (uint8_t *) malloc(msg_len);

    memset(ad, 0xAA, ad_len);
    memset(msg, 0xBB, msg_len);

    uint8_t tag1[HIAE_MACBYTES], tag2[HIAE_MACBYTES];

    HiAE_state_t state1, state2;

    // Test 1: Using regular enc/dec
    HiAE_init(&state1, key, nonce);
    HiAE_absorb(&state1, ad, ad_len);
    HiAE_enc(&state1, ct1, msg, msg_len);
    HiAE_finalize(&state1, ad_len, msg_len, tag1);

    HiAE_init(&state1, key, nonce);
    HiAE_absorb(&state1, ad, ad_len);
    HiAE_dec(&state1, decoded1, ct1, msg_len);
    HiAE_finalize(&state1, ad_len, msg_len, tag2);

    // Test 2: Using partial_noupdate for the last few bytes
    size_t partial_len = msg_len % 16; // Last partial block
    size_t full_len    = msg_len - partial_len;

    // Encryption with mixed API
    HiAE_init(&state2, key, nonce);
    HiAE_absorb(&state2, ad, ad_len);
    if (full_len > 0) {
        HiAE_enc(&state2, ct2, msg, full_len);
    }
    // Use partial_noupdate for the remaining bytes, then update state manually
    if (partial_len > 0) {
        HiAE_enc_partial_noupdate(&state2, ct2 + full_len, msg + full_len, partial_len);
        // To maintain consistency, we need to update the state
        HiAE_enc(&state2, ct2 + full_len, msg + full_len, partial_len);
    }
    HiAE_finalize(&state2, ad_len, msg_len, tag2);

    // Results should be identical
    int same_ct      = memcmp(ct1, ct2, msg_len);
    int same_tag     = memcmp(tag1, tag2, HIAE_MACBYTES);
    int same_decoded = memcmp(msg, decoded1, msg_len);

    free(ad);
    free(msg);
    free(ct1);
    free(ct2);
    free(decoded1);
    free(decoded2);

    int passed = same_ct | same_tag | same_decoded;

    if (!passed) {
        printf("passed API: [partial_noupdate functional] test\n");
    } else {
        printf("FAILED: partial_noupdate functional test\n");
    }

    return passed;
}

int
main(void)
{
    printf("========HiAE API Test========\n");
    int pass_API = 0;
    pass_API |= stream_API_test_case_1();
    pass_API |= AEAD_API_test_case_1();
    pass_API |= Verification_API_test_case_1();
    pass_API |= Verification_API_test_case_2();
    pass_API |= partial_noupdate_test_case_1();
    pass_API |= partial_noupdate_test_case_2();
    pass_API |= partial_noupdate_functional_test();
    if (!pass_API)
        printf("passed all API test\n\n");
    else
        printf("API test failed !!!\n\n");

    printf("========HiAE Functional Test========\n");
    functional_test();
}
